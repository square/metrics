# Copyright 2015 Square Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

package query

type Parser Peg {
  // temporary variables
  // ===================

  // stack of nodes used during the AST traversal.
  // a non-empty stack at the finish implies a programming error.
  nodeStack  []Node

  // user errors accumulated during the AST traversal.
  // a non-empty list at the finish time means an invalid query is provided.
  errors     []SyntaxError

  // programming errors accumulated during the AST traversal.
  // a non-empty list at the finish time implies a programming error.
  assertions []error

  // final result
  command    Command
}

# The following queries are support

# describe all              <- describe all statement - returns all metric keys.
# describe metric where ... <- describes a single metric - returns all tagsets within a single metric key.
# select ...                <- select statement - retrieves, transforms, and aggregates time serieses.

# Refer to the unit test query_test.go for more info.

# Hierarchical Syntax
# ===================

root <- (selectStmt / describeStmt) !.

selectStmt <-   "select" __
  expressionList
  optionalPredicateClause
  propertyClause {
    p.makeSelect()
  }

describeStmt <- "describe" __ (describeAllStmt / describeSingleStmt)

describeAllStmt <- "all" { p.makeDescribeAll() }

describeSingleStmt <-
  <METRIC_NAME> { p.addStringLiteral(unescapeLiteral(buffer[begin:end])) }
  optionalPredicateClause
  { p.makeDescribe() }

propertyClause <-
  (_ PROPERTY_KEY __ PROPERTY_VALUE)*

optionalPredicateClause <-
  __ predicateClause / { p.addNullPredicate() }

# expression_X are layered to maintain the order of operations.

expressionList <-
  { p.addExpressionList() }
  expression_1 { p.appendExpression() }
  (
    COMMA expression_1 { p.appendExpression() }
  )*

expression_1 <-
  expression_2
  (
    (OP_ADD { p.addOperatorLiteral("*") } / OP_SUB { p.addOperatorLiteral("-") })
    expression_2 { p.addOperatorFunction() }
  ) *

expression_2 <-
  expression_3
  (
    (OP_DIV { p.addOperatorLiteral("*") } / OP_MULT { p.addOperatorLiteral("*") })
    expression_3 { p.addOperatorFunction() }
  ) *

expression_3 <-
  expression_function /
  expression_metric /
  # #sub-expression
  PAREN_OPEN expression_1 PAREN_CLOSE /
  # constant scalar
  <NUMBER> { p.addNumberNode(buffer[begin:end]) }

expression_function  <-
  # We allow syntax of the form:
  # func(expr_a, expr_b, expr_c group by column_a, column_b, column_c)
  # a single optional group-by clause.
  <IDENTIFIER> {
    p.addStringLiteral(unescapeLiteral(buffer[begin:end]))
  }
  PAREN_OPEN
    expressionList { p.addGroupBy() } (__ groupByClause)?
  PAREN_CLOSE {
    p.addFunctionInvocation()
  }

expression_metric <-
  <IDENTIFIER> {
    p.addStringLiteral(unescapeLiteral(buffer[begin:end]))
  }
  ("[" _ predicate_1 _ "]" / { p.addNullPredicate() })? {
    p.addMetricExpression()
  }

groupByClause <-
  "group" __ "by" __ <COLUMN_NAME> {
    p.appendGroupBy(unescapeLiteral(buffer[begin:end]))
  }
  (
    COMMA <COLUMN_NAME> {
    p.appendGroupBy(unescapeLiteral(buffer[begin:end]))
    }
  )*

predicateClause <- "where" __ predicate_1

# predicate_X are layered to maintain the order of operations.
# not
# or
# and
# ...

predicate_1 <-
  predicate_2 OP_OR predicate_1 { p.addOrPredicate() } /
  predicate_2 /

predicate_2 <-
  predicate_3 OP_AND predicate_2 { p.addAndPredicate() } /
  predicate_3

predicate_3 <-
  OP_NOT predicate_3 { p.addNotPredicate() } /
  PAREN_OPEN predicate_1 PAREN_CLOSE /
  tagMatcher

tagMatcher <-
  tagName _ "=" _ literalString {
    p.addLiteralMatcher()
  } /
  tagName _ "!=" _ literalString {
    p.addLiteralMatcher()
    p.addNotPredicate()
  } /
  tagName __ "matches" __ literalString {
    p.addRegexMatcher()
  } /
  tagName __ "in" __ literalList {
    p.addListMatcher()
  }

literalString <- <STRING> {
  p.addStringLiteral(unescapeLiteral(buffer[begin:end]))
}

literalList <- { p.addLiteralList() }
  PAREN_OPEN
    literalListString (COMMA literalListString)*
  PAREN_CLOSE

literalListString <- STRING {
  p.appendLiteral(unescapeLiteral(buffer[begin:end]))
}

tagName <-
  <TAG_NAME> { p.addTagLiteral(unescapeLiteral(buffer[begin:end])) }

# Lexical Syntax
# ==============
# Convention: These rules contain no code blocks.

COLUMN_NAME <- IDENTIFIER
METRIC_NAME <- IDENTIFIER
TAG_NAME <-    IDENTIFIER
# TODO - may be refactored later.
TIMESTAMP <-   NUMBER_NATURAL / STRING
IDENTIFIER <-  "`" CHAR* "`" / !KEYWORD ID_SEGMENT ("." ID_SEGMENT)*
ID_SEGMENT <-  ID_START ID_CONT*
# Hyphen (-) is intentionally omitted, since it makes the language ambiguous.
# If hyphens are needed, use backticks instead.
ID_START <-    [a-zA-Z_]
ID_CONT <-     ID_START / [0-9]

PROPERTY_KEY <-
  "from" /
  "to" /
  "resolution" /
  "sample" __ "by"

PROPERTY_VALUE <- TIMESTAMP

KEYWORD <-     # List of keywrods used throughout the code.
  "all" /
  "and" /
  "as" /
  "by" /
  "describe" /
  "group" /
  "in" /
  "matches" /
  "not" /
  "or" /
  "select" /
  "where" /
  PROPERTY_KEY

# Operators
# =========

OP_ADD  <- _ "+" _
OP_SUB  <- _ "-" _
OP_MULT <- _ "*" _
OP_DIV  <- _ "/" _
OP_AND  <- __ "and" __
OP_OR   <- __ "or" __
OP_NOT  <- "not" __

STRING <-      "'" CHAR* "'" / '"' CHAR* '"'

CHAR         <- "\\" ESCAPE_CLASS / ! ESCAPE_CLASS .
# TODO - this currently doesn't support not-escaping single-quotes within quotes, vice versa.
ESCAPE_CLASS <- ("'" / "`" / "\"" / "\\")

# Numerical elements
# ==================

# Definition for floating point numbers.
# modelled after JSON (http://json.org/)
NUMBER          <- NUMBER_INTEGER NUMBER_FRACTION? NUMBER_EXP?
NUMBER_NATURAL  <- "0" / [1-9] [0-9]*
NUMBER_FRACTION <- "." [0-9]+
NUMBER_INTEGER  <- "-"? NUMBER_NATURAL
NUMBER_EXP      <- "e" ("+" / "-")? [0-9]+

# Syntactic elements
# ==================

PAREN_OPEN <-  _ "(" _
PAREN_CLOSE <- _ ")" _
COMMA <-       _ "," _
_  <-          SPACE* # Optional spaces
__ <-          SPACE+ # Required spaces
SPACE <-       " " / "\n" / "\t"
